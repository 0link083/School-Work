// Project 7 C++ Software Development
// The one about THREADS
#include <iostream>
#include <fstream>
#include <queue>
#include <array>
#include <sstream>
#include <string>
#include <atomic>
#include <cassert>
#include <condition_variable>
#include <cstddef>
#include <cstdlib>
#include <mutex>
#include <thread>

#define numOfRand 1000

using namespace std; // I got lazy okay.

class Pipeline {
	// Data Structure
	static queue<int> filtererQueue; // Keeps the random number generated by producer threads. Locked
	static queue<int> grouperQueue; // Keeps the queue for the groupers to sort from. Locked
	static array<int, 10> numOfNums; // Keeps track of the number of items in this group. Not Locked

	// Locks
	static mutex grouperQueueLock; // lock for grouperQueue
	static mutex filtererQueueLock; // lock for filtererQueue
	static mutex out; // lock std out

	// Signals / Condition Variables
	static condition_variable producerToFilterer;	// signal producers done
	static condition_variable filtererToGrouper;	// signal filterers done

	// Data for thread management
	static atomic_size_t nprod; // number of producer threads active
	static atomic_size_t nfilt; // number of filterer threads active
	static atomic_size_t ngroup; // number of grouper threads active

public:
	static const size_t nprods = 4, nfilts = 3, ngroups = 10; // The number of threads for each process

	static void producer(int num) {
		srand(time(nullptr) + num * (num + 1));
		for (int i = 0; i < 1000; ++i) { // supposedly this i is shared? not exactly sure how that works.
			int n = rand();     // Get random int

			unique_lock<mutex> fblck(filtererQueueLock); // lock filtererQueueBack
			filtererQueue.emplace(n); // Generate Random Number
			// unlock filtererQueueBack by letting it fall out of scope
			producerToFilterer.notify_one(); // notifyOne filterer since it does not matter which fulfills the order.
		}
		unique_lock<mutex> fblck(filtererQueueLock); // lock filtererQueueBack
		--nprod; // Decrement Producer count by one.
		producerToFilterer.notify_all(); // Notify all Filter threads of one producer ending its term..
	}

	static void filterer() {
		while (true) {
			unique_lock<mutex> fflck(filtererQueueLock); // lock front of filterer queue for removal
			producerToFilterer.wait(fflck, []() {return !filtererQueue.empty() || !nprod; }); // from condition_variable, this statement saves CPU time by providing an alternative to spinlock. If condition is unmet the lock is freed. As if this never happened.
			if (filtererQueue.empty()) {
				assert(!nprod); // Fail if there is a producer still running.
				break;
			}
			int toBeJudged = filtererQueue.front(); // Should be an int
			filtererQueue.pop(); // And now I understand why pop and front are seperate commands.
			fflck.unlock(); // filter unlock front
			if (toBeJudged % 3 != 0) {
				unique_lock<mutex> gblock(grouperQueueLock); // lock back of grouperQueue for insertion
				grouperQueue.emplace(toBeJudged); // And now I understand why these are seperate commands.
				// unlock grouperQueue back by falling out of scope
				filtererToGrouper.notify_all(); // notifyAll groupers since it does matter which it goes to and we can not specify
			}
		}
		unique_lock<mutex> fflck(filtererQueueLock); // lock front of filterer queue for removal
		--nfilt; // Decrement a signal for each filterer, when all are done we are done and the groupers must know.
		filtererToGrouper.notify_all();
	}
	
	static void grouper(int num) {
		// Somehow these must identify themselves. We will use num to initialize it.
		stringstream surfingTheFileStream;
		surfingTheFileStream << num;
		string filename = surfingTheFileStream.str() + ".txt";
		ofstream outFile;
		outFile.open(filename);
		while (true){
			unique_lock<mutex> gflck(grouperQueueLock);
			filtererToGrouper.wait(gflck,[](){return !grouperQueue.empty() || !nfilt; });
			if (grouperQueue.empty()) {
				assert(!nfilt);
				break;
			}
			int toBeJudged = grouperQueue.front();
			if (toBeJudged % 10 == num) {
				grouperQueue.pop(); // And now I understand why these are seperate commands.
				gflck.unlock(); // unlock since outfile write is expensive to hold grouper resource.
				outFile << toBeJudged << endl;
				++numOfNums[num];
			}
		}
		unique_lock<mutex> o(out);
		--ngroup; // Sanity check in main.
		cout << "Group "<< num << " has " << numOfNums[num] << " numbers" << endl;
	}
};

// Define static class data members
queue<int> Pipeline::filtererQueue;
queue<int> Pipeline::grouperQueue;
array<int, 10> Pipeline::numOfNums;
condition_variable Pipeline::producerToFilterer, Pipeline::filtererToGrouper;
mutex Pipeline::grouperQueueLock, Pipeline::filtererQueueLock, Pipeline::out;
atomic_size_t Pipeline::nprod(nprods), Pipeline::nfilt(nfilts), Pipeline::ngroup(ngroups);

int main() {
	vector<thread> prods, filts, groups;

	for (size_t i = 0; i < Pipeline::nprods; ++i)	// Spin up 4 producers threads
		prods.push_back(thread(&Pipeline::producer, i));
	for (size_t i = 0; i < Pipeline::nfilts; ++i)	// Spin up 3 filter threads
		filts.push_back(thread(&Pipeline::filterer));
	for (size_t i = 0; i < Pipeline::ngroups; ++i)	// Spin up 10 grouper threads
		groups.push_back(thread(&Pipeline::grouper, i));
	
	// Join producers, filters, groupers.
	for (auto &p : prods)
		p.join();
	for (auto &f : filts)
		f.join();
	for (auto &g : groups)
		g.join();
	return 0;
}